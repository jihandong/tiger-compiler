%{

/********************************************************************************
 * Includes
 ********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "ast.h"
#include "symbol.h"

/********************************************************************************
 * External
 ********************************************************************************/

A_exp A_root;

extern FILE *yyin;
int yyparse(void);
int yylex(void);

/********************************************************************************
 * Public
 ********************************************************************************/

void yyerror(char *s)
{
    fprintf(stderr, "Parse error: \"%s\"\n", s);
}

int parse(const char *filename)
{
    int ret;

    yyin = fopen(filename, "r");
    if (!yyin) {
        fprintf(stderr, "cannot open %s\n", filename);
        exit(1);
    }

    A_root = NULL;
    ret = yyparse();

    fclose(yyin);
    return ret;
}

/********************************************************************************
 * End
 ********************************************************************************/

%}

%union
{
    int                         pos;
    int                         ival;
    const char *                sval;
    A_dec                     dec;
    A_exp                     exp;
    A_var                     var;
    A_type                    type;
    A_dec_list                decs;
    A_exp_list                exps;
    A_para                  para;
    A_para_list             paras;
    A_argu                  argu;
    A_argu_list             argus;
}

%token <ival>   INT
%token <sval>   ID STRING
%token          COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE
                DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN
                ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF BREAK NIL
                FUNCTION VAR TYPE

%nonassoc   ASSIGN
%left       AND OR
%nonassoc   EQ NEQ LT LE GT GE
%left       PLUS MINUS
%left       TIMES DIVIDE
%nonassoc   UMINUS

%type <dec>     dec dec_var dec_type dec_func
%type <exp>     program exp exp_value exp_seq exp_op exp_call exp_create
                exp_assign exp_if exp_for exp_while exp_break exp_let
%type <var>     lvalue lvalue_suffix
%type <type>    type
%type <decs>    decs
%type <exps>    seqfs argfs
%type <para>  para
%type <paras> paras
%type <argu>  argu
%type <argus> argus

%start program

%%

program: exp { A_root = $1; }

/****************************************************************************
 * declares
 ****************************************************************************/

decs
: /* epsilon */     { $$ = NULL; }
| dec decs          { $$ = A_mk_dec_list($1, $2); }

dec
: dec_var   { printf("declaration(var)\n"); $$ = $1; }
| dec_type  { printf("declaration(type)\n"); $$ = $1; }
| dec_func  { printf("declaration(func)\n"); $$ = $1; }

dec_var
: VAR ID ASSIGN exp             { $$ = A_mk_dec_var(0, S_mk_symbol($2), NULL, $4); }
| VAR ID COLON ID ASSIGN exp    { $$ = A_mk_dec_var(0, S_mk_symbol($2), S_mk_symbol($4), $6); }

dec_type
: TYPE ID EQ type   { $$ = A_mk_dec_type(S_mk_symbol($2), $4); }

dec_func
: FUNCTION ID LPAREN RPAREN EQ exp                  { $$ = A_mk_dec_func(0, S_mk_symbol($2), NULL, NULL, $6); }
| FUNCTION ID LPAREN RPAREN COLON ID EQ exp         { $$ = A_mk_dec_func(0, S_mk_symbol($2), NULL, S_mk_symbol($6), $8); }
| FUNCTION ID LPAREN paras RPAREN EQ exp           { $$ = A_mk_dec_func(0, S_mk_symbol($2), $4, NULL, $7); }
| FUNCTION ID LPAREN paras RPAREN COLON ID EQ exp  { $$ = A_mk_dec_func(0, S_mk_symbol($2), $4, S_mk_symbol($7), $9); }

/****************************************************************************
 * expressions
 ****************************************************************************/

exp
: exp_value     { printf("expression(value)\n");    $$ = $1; }
| exp_seq       { printf("expression(seq)\n");      $$ = $1; }
| exp_op        { printf("expression(op)\n");       $$ = $1; }
| exp_call      { printf("expression(call)\n");     $$ = $1; }
| exp_create    { printf("expression(create)\n");   $$ = $1; }
| exp_assign    { printf("expression(assign)\n");   $$ = $1; }
| exp_if        { printf("expression(if)\n");       $$ = $1; }
| exp_for       { printf("expression(for)\n");      $$ = $1; }
| exp_while     { printf("expression(while)\n");    $$ = $1; }
| exp_break     { printf("expression(break)\n");    $$ = $1; }
| exp_let       { printf("expression(let)\n");      $$ = $1; }
| error         { ; }

exp_value
: NIL       { $$ = A_mk_exp_nil(0); }
| INT       { $$ = A_mk_exp_int(0, $1); }
| STRING    { $$ = A_mk_exp_string(0, $1); }
| lvalue    { $$ = A_mk_exp_var(0, $1); }

exp_seq
: LPAREN seqfs RPAREN { $$ = A_mk_exp_seq(0, $2); }

exp_op
: exp PLUS exp              { $$ = A_mk_exp_op(0, A_kind_op_plus,   $1, $3); }
| exp MINUS exp             { $$ = A_mk_exp_op(0, A_kind_op_minus,  $1, $3); }
| exp TIMES exp             { $$ = A_mk_exp_op(0, A_kind_op_times,  $1, $3); }
| exp DIVIDE exp            { $$ = A_mk_exp_op(0, A_kind_op_divide, $1, $3); }
| exp EQ exp                { $$ = A_mk_exp_op(0, A_kind_op_eq,     $1, $3); }
| exp NEQ exp               { $$ = A_mk_exp_op(0, A_kind_op_neq,    $1, $3); }
| exp LT exp                { $$ = A_mk_exp_op(0, A_kind_op_lt,     $1, $3); }
| exp LE exp                { $$ = A_mk_exp_op(0, A_kind_op_le,     $1, $3); }
| exp GT exp                { $$ = A_mk_exp_op(0, A_kind_op_gt,     $1, $3); }
| exp GE exp                { $$ = A_mk_exp_op(0, A_kind_op_ge,     $1, $3); }
| MINUS exp %prec UMINUS    { $$ = A_mk_exp_op(0, A_kind_op_minus,  A_mk_exp_int(0, 0), $2); }

exp_call
: ID LPAREN RPAREN          { $$ = A_mk_exp_call(0, S_mk_symbol($1), NULL); }
| ID LPAREN argfs RPAREN    { $$ = A_mk_exp_call(0, S_mk_symbol($1), $3); }

exp_create
: ID LBRACE RBRACE              { $$ = A_mk_exp_record(0, S_mk_symbol($1), NULL); }
| ID LBRACE argus RBRACE     { $$ = A_mk_exp_record(0, S_mk_symbol($1), $3); }
| ID LBRACK exp RBRACK OF exp   { $$ = A_mk_exp_array(0, S_mk_symbol($1), $3, $6); }

exp_assign
: lvalue ASSIGN exp { $$ = A_mk_exp_assign(0, $1, $3); }

exp_if
: IF exp THEN exp ELSE exp  { $$ = A_mk_exp_if(0, $2, $4, $6); }
| IF exp THEN exp           { $$ = A_mk_exp_if(0, $2, $4, NULL); }
| exp AND exp               { $$ = A_mk_exp_if(0, $1, $3, A_mk_exp_int(0, 0)); }
| exp OR exp                { $$ = A_mk_exp_if(0, $1, A_mk_exp_int(0, 1), $3); }

exp_for
: FOR ID ASSIGN exp TO exp DO exp { $$ = A_mk_exp_for(0, S_mk_symbol($2), $4, $6, $8); }

exp_while
: WHILE exp DO exp { $$ = A_mk_exp_while(0, $2, $4); }

exp_break
: BREAK { $$ = A_mk_exp_break(0); }

exp_let
: LET decs IN seqfs END { $$ = A_mk_exp_let(0, $2, $4); }

/****************************************************************************
 * variables
 ****************************************************************************/

lvalue
: ID                { $$ = A_mk_var(0, S_mk_symbol($1), NULL); }
| ID lvalue_suffix  { $$ = A_mk_var(0, S_mk_symbol($1), $2); }

lvalue_suffix
: /* spsilon */                     { $$ = NULL; }
| LBRACK exp RBRACK lvalue_suffix   { $$ = A_mk_var_slice(0, $2, $4); }
| DOT ID lvalue_suffix              { $$ = A_mk_var_member(0, S_mk_symbol($2), $3); }

/****************************************************************************
 * types
 ****************************************************************************/

type
: ID                    { printf("type(simple)\n"); $$ = A_mk_type_var(0, S_mk_symbol($1)); }
| ARRAY OF ID           { printf("type(array)\n");  $$ = A_mk_type_array(0, S_mk_symbol($3)); }
| LBRACE paras RBRACE  { printf("type(record)\n"); $$ = A_mk_type_record(0, $2); }
| LBRACE RBRACE         { printf("type(record)\n"); $$ = A_mk_type_record(0, NULL); }

/****************************************************************************
 * link list
 ****************************************************************************/

paras
: para                 { $$ = A_mk_para_list($1, NULL); }
| para COMMA paras    { $$ = A_mk_para_list($1, $3); }

para
: ID COLON ID   { $$ = A_mk_para(0, S_mk_symbol($1), S_mk_symbol($3)); }

argus
: argu                   { $$ = A_mk_argu_list($1, NULL); }
| argu COMMA argus    { $$ = A_mk_argu_list($1, $3); }

argu
: ID EQ exp { $$ = A_mk_argu(S_mk_symbol($1), $3); }

seqfs
: exp                   { $$ = A_mk_exp_list($1, NULL); }
| exp SEMICOLON seqfs   { $$ = A_mk_exp_list($1, $3); }

argfs
: exp               { $$ = A_mk_exp_list($1, NULL); }
| exp COMMA argfs   { $$ = A_mk_exp_list($1, $3); }

