%{

/********************************************************************************
 * Includes
 ********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "ast.h"
#include "symbol.h"

/********************************************************************************
 * External
 ********************************************************************************/

ast_exp ast_root;

extern FILE *yyin;
int yyparse(void);
int yylex(void);

/********************************************************************************
 * Public
 ********************************************************************************/

void yyerror(char *s)
{
    fprintf(stderr, "Parse error: \"%s\"\n", s);
}

int parse(const char *filename)
{
    int ret;

    yyin = fopen(filename, "r");
    if (!yyin) {
        fprintf(stderr, "cannot open %s\n", filename);
        exit(1);
    }

    ast_root = NULL;
    ret = yyparse();

    fclose(yyin);
    return ret;
}

/********************************************************************************
 * End
 ********************************************************************************/

%}

%union
{
    int                         pos;
    int                         ival;
    const char *                sval;
    ast_dec                     dec;
    ast_exp                     exp;
    ast_var                     var;
    ast_type                    type;
    ast_dec_list                decs;
    ast_exp_list                exps;
    ast_tfield                  tfield;
    ast_tfield_list             tfields;
    ast_rfield                  rfield;
    ast_rfield_list             rfields;
}

%token <ival>   INT
%token <sval>   ID STRING
%token          COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE
                DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN
                ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF BREAK NIL
                FUNCTION VAR TYPE

%nonassoc   ASSIGN
%left       AND OR
%nonassoc   EQ NEQ LT LE GT GE
%left       PLUS MINUS
%left       TIMES DIVIDE
%nonassoc   UMINUS

%type <dec>     dec dec_var dec_type dec_func
%type <exp>     program exp exp_value exp_seq exp_op exp_call exp_create
                exp_assign exp_if exp_for exp_while exp_break exp_let
%type <var>     lvalue lvalue_suffix
%type <type>    type
%type <decs>    decs
%type <exps>    seqfs argfs
%type <tfield>  typef
%type <tfields> typefs
%type <rfield>  recordf
%type <rfields> recordfs

%start program

%%

program: exp { ast_root = $1; }

/****************************************************************************
 * declares
 ****************************************************************************/

decs
: /* epsilon */     { $$ = NULL; }
| dec decs          { $$ = ast_mk_dec_list($1, $2); }

dec
: dec_var   { printf("declaration(var)\n"); $$ = $1; }
| dec_type  { printf("declaration(type)\n"); $$ = $1; }
| dec_func  { printf("declaration(func)\n"); $$ = $1; }

dec_var
: VAR ID ASSIGN exp             { $$ = ast_mk_dec_var(0, sym_get($2), NULL, $4); }
| VAR ID COLON ID ASSIGN exp    { $$ = ast_mk_dec_var(0, sym_get($2), sym_get($4), $6); }

dec_type
: TYPE ID EQ type   { $$ = ast_mk_dec_type(sym_get($2), $4); }

dec_func
: FUNCTION ID LPAREN RPAREN EQ exp                  { $$ = ast_mk_dec_func(0, sym_get($2), NULL, NULL, $6); }
| FUNCTION ID LPAREN RPAREN COLON ID EQ exp         { $$ = ast_mk_dec_func(0, sym_get($2), NULL, sym_get($6), $8); }
| FUNCTION ID LPAREN typefs RPAREN EQ exp           { $$ = ast_mk_dec_func(0, sym_get($2), $4, NULL, $7); }
| FUNCTION ID LPAREN typefs RPAREN COLON ID EQ exp  { $$ = ast_mk_dec_func(0, sym_get($2), $4, sym_get($7), $9); }

/****************************************************************************
 * expressions
 ****************************************************************************/

exp
: exp_value     { printf("expression(value)\n");    $$ = $1; }
| exp_seq       { printf("expression(seq)\n");      $$ = $1; }
| exp_op        { printf("expression(op)\n");       $$ = $1; }
| exp_call      { printf("expression(call)\n");     $$ = $1; }
| exp_create    { printf("expression(create)\n");   $$ = $1; }
| exp_assign    { printf("expression(assign)\n");   $$ = $1; }
| exp_if        { printf("expression(if)\n");       $$ = $1; }
| exp_for       { printf("expression(for)\n");      $$ = $1; }
| exp_while     { printf("expression(while)\n");    $$ = $1; }
| exp_break     { printf("expression(break)\n");    $$ = $1; }
| exp_let       { printf("expression(let)\n");      $$ = $1; }
| error         { ; }

exp_value
: NIL       { $$ = ast_mk_exp_nil(0); }
| INT       { $$ = ast_mk_exp_int(0, $1); }
| STRING    { $$ = ast_mk_exp_string(0, $1); }
| lvalue    { $$ = ast_mk_exp_var(0, $1); }

exp_seq
: LPAREN seqfs RPAREN { $$ = ast_mk_exp_seq(0, $2); }

exp_op
: exp PLUS exp              { $$ = ast_mk_exp_op(0, kind_op_plus,   $1, $3); }
| exp MINUS exp             { $$ = ast_mk_exp_op(0, kind_op_minus,  $1, $3); }
| exp TIMES exp             { $$ = ast_mk_exp_op(0, kind_op_times,  $1, $3); }
| exp DIVIDE exp            { $$ = ast_mk_exp_op(0, kind_op_divide, $1, $3); }
| exp EQ exp                { $$ = ast_mk_exp_op(0, kind_op_eq,     $1, $3); }
| exp NEQ exp               { $$ = ast_mk_exp_op(0, kind_op_neq,    $1, $3); }
| exp LT exp                { $$ = ast_mk_exp_op(0, kind_op_lt,     $1, $3); }
| exp LE exp                { $$ = ast_mk_exp_op(0, kind_op_le,     $1, $3); }
| exp GT exp                { $$ = ast_mk_exp_op(0, kind_op_gt,     $1, $3); }
| exp GE exp                { $$ = ast_mk_exp_op(0, kind_op_ge,     $1, $3); }
| MINUS exp %prec UMINUS    { $$ = ast_mk_exp_op(0, kind_op_minus,  ast_mk_exp_int(0, 0), $2); }

exp_call
: ID LPAREN RPAREN          { $$ = ast_mk_exp_call(0, sym_get($1), NULL); }
| ID LPAREN argfs RPAREN    { $$ = ast_mk_exp_call(0, sym_get($1), $3); }

exp_create
: ID LBRACE RBRACE              { $$ = ast_mk_exp_record(0, sym_get($1), NULL); }
| ID LBRACE recordfs RBRACE     { $$ = ast_mk_exp_record(0, sym_get($1), $3); }
| ID LBRACK exp RBRACK OF exp   { $$ = ast_mk_exp_array(0, sym_get($1), $3, $6); }

exp_assign
: lvalue ASSIGN exp { $$ = ast_mk_exp_assign(0, $1, $3); }

exp_if
: IF exp THEN exp ELSE exp  { $$ = ast_mk_exp_if(0, $2, $4, $6); }
| IF exp THEN exp           { $$ = ast_mk_exp_if(0, $2, $4, NULL); }
| exp AND exp               { $$ = ast_mk_exp_if(0, $1, $3, ast_mk_exp_int(0, 0)); }
| exp OR exp                { $$ = ast_mk_exp_if(0, $1, ast_mk_exp_int(0, 1), $3); }

exp_for
: FOR ID ASSIGN exp TO exp DO exp { $$ = ast_mk_exp_for(0, sym_get($2), $4, $6, $8); }

exp_while
: WHILE exp DO exp { $$ = ast_mk_exp_while(0, $2, $4); }

exp_break
: BREAK { $$ = ast_mk_exp_break(0); }

exp_let
: LET decs IN seqfs END { $$ = ast_mk_exp_let(0, $2, $4); }

/****************************************************************************
 * variables
 ****************************************************************************/

lvalue
: ID                { $$ = ast_mk_var(0, sym_get($1), NULL); }
| ID lvalue_suffix  { $$ = ast_mk_var(0, sym_get($1), $2); }

lvalue_suffix
: /* spsilon */                     { $$ = NULL; }
| LBRACK exp RBRACK lvalue_suffix   { $$ = ast_mk_var_slice(0, $2, $4); }
| DOT ID lvalue_suffix              { $$ = ast_mk_var_member(0, sym_get($2), $3); }

/****************************************************************************
 * types
 ****************************************************************************/

type
: ID                    { printf("type(simple)\n"); $$ = ast_mk_type_var(0, sym_get($1)); }
| ARRAY OF ID           { printf("type(array)\n"); $$ = ast_mk_type_array(0, sym_get($3)); }
| LBRACE typefs RBRACE  { printf("type(record)\n"); $$ = ast_mk_type_record(0, $2); }
| LBRACE RBRACE         { printf("type(record)\n"); $$ = ast_mk_type_record(0, NULL); }

/****************************************************************************
 * link list
 ****************************************************************************/

typefs
: typef                 { $$ = ast_mk_tfield_list($1, NULL); }
| typef COMMA typefs    { $$ = ast_mk_tfield_list($1, $3); }

typef
: ID COLON ID   { $$ = ast_mk_tfield(0, sym_get($1), sym_get($3)); }

recordfs
: recordf                   { $$ = ast_mk_rfield_list($1, NULL); }
| recordf COMMA recordfs    { $$ = ast_mk_rfield_list($1, $3); }

recordf
: ID EQ exp { $$ = ast_mk_rfield(sym_get($1), $3); }

seqfs
: exp                   { $$ = ast_mk_exp_list($1, NULL); }
| exp SEMICOLON seqfs   { $$ = ast_mk_exp_list($1, $3); }

argfs
: exp               { $$ = ast_mk_exp_list($1, NULL); }
| exp COMMA argfs   { $$ = ast_mk_exp_list($1, $3); }
