%{

/********************************************************************************
 * Includes
 ********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include "ast.h"
#include "symbol.h"

/********************************************************************************
 * External
 ********************************************************************************/

extern FILE *yyin;
int yyparse(void);
int yylex(void);

/********************************************************************************
 * Private
 ********************************************************************************/

static ast_exp ast_root;

/********************************************************************************
 * Public
 ********************************************************************************/

void yyerror(char *s)
{
    fprintf(stderr, "Parse error: \"%s\"\n", s);
}

ast_exp parse(const char *filename)
{
    ast_exp ret = NULL;

    yyin = fopen(filename, "r");
    if (!yyin) {
        fprintf(stderr, "cannot open %s\n", filename);
        exit(1);
    }

    if (yyparse())
        ret = ast_root;

    fclose(yyin);
    return ret;
}

/********************************************************************************
 * End
 ********************************************************************************/

%}

%union
{
	int                 pos;
	int                 ival;
	const char *        sval;
    ast_dec             dec;
    ast_exp             exp;
    ast_var             var;
    ast_type            type;
    ast_dec_list        decs;
    ast_exp_list        exps;
    ast_tfield          tfield;
    ast_tfield_list     tfields;
    ast_rfield          rfield;
    ast_rfield_list     rfields;
}

%token <ival>   INT
%token <sval>   ID STRING
%token          COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE
                DOT PLUS MINUS TIMES DIVIDE EQ NEQ LT LE GT GE AND OR ASSIGN
                ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF BREAK NIL
                FUNCTION VAR TYPE

%nonassoc   ASSIGN
%left       AND OR
%nonassoc   EQ NEQ LT LE GT GE
%left       PLUS MINUS
%left       TIMES DIVIDE
%left       UMINUS

%type <dec>     dec dec_var dec_type dec_func
%type <exp>     program exp exp_value exp_seq exp_op exp_call exp_create
                exp_assign exp_if exp_for exp_while exp_break exp_let
%type <var>     lvalue
%type <type>    type
%type <decs>    decs
%type <exps>    seq_fields arg_fields
%type <tfield>  type_field
%type <tfields> type_fields
%type <rfield>  record_field
%type <rfields> record_fields

%start program

%%

program: exp { ast_root = $1; }

/****************************************************************************
 * declares
 ****************************************************************************/

decs
: /* epsilon */     { $$ = NULL; }
| dec decs          { $$ = ast_mk_dec_list($1, $2); }

dec
: dec_var   { $$ = $1; }
| dec_type  { $$ = $1; }
| dec_func  { $$ = $1; }

dec_var
: VAR ID ASSIGN exp             { $$ = ast_mk_dec_var(0, sym_get($2), NULL, $4); }
| VAR ID COLON ID ASSIGN exp    { $$ = ast_mk_dec_var(0, sym_get($2), sym_get($4), $6); }

dec_type
: TYPE ID EQ type   { $$ = ast_mk_dec_type(sym_get($2), $4); }

dec_func
: FUNCTION ID LPAREN type_fields RPAREN EQ exp          { $$ = ast_mk_dec_func(0, sym_get($2), $4, NULL, $7); }
| FUNCTION ID LPAREN type_fields RPAREN COLON ID EQ exp { $$ = ast_mk_dec_func(0, sym_get($2), $4, sym_get($7), $9); }

/****************************************************************************
 * expressions
 ****************************************************************************/

exp
: exp_value     { $$ = $1; }
| exp_seq       { $$ = $1; }
| exp_op        { $$ = $1; }
| exp_call      { $$ = $1; }
| exp_create    { $$ = $1; }
| exp_assign    { $$ = $1; }
| exp_if        { $$ = $1; }
| exp_for       { $$ = $1; }
| exp_while     { $$ = $1; }
| exp_break     { $$ = $1; }
| exp_let       { $$ = $1; }
| error         { $$ = NULL; }

exp_value
: NIL       { $$ = ast_mk_exp_nil(0); }
| INT       { $$ = ast_mk_exp_int(0, $1); }
| STRING    { $$ = ast_mk_exp_string(0, $1); }
| lvalue    { $$ = ast_mk_exp_var(0, $1); }

exp_seq
: LPAREN seq_fields RPAREN { $$ = ast_mk_exp_seq(0, $2); }

exp_op
: exp PLUS exp              { $$ = ast_mk_exp_op(0, kind_op_plus,   $1, $3); }
| exp MINUS exp             { $$ = ast_mk_exp_op(0, kind_op_minus,  $1, $3); }
| exp TIMES exp             { $$ = ast_mk_exp_op(0, kind_op_times,  $1, $3); }
| exp DIVIDE exp            { $$ = ast_mk_exp_op(0, kind_op_divide, $1, $3); }
| exp EQ exp                { $$ = ast_mk_exp_op(0, kind_op_eq,     $1, $3); }
| exp NEQ exp               { $$ = ast_mk_exp_op(0, kind_op_neq,    $1, $3); }
| exp LT exp                { $$ = ast_mk_exp_op(0, kind_op_lt,     $1, $3); }
| exp LE exp                { $$ = ast_mk_exp_op(0, kind_op_le,     $1, $3); }
| exp GT exp                { $$ = ast_mk_exp_op(0, kind_op_gt,     $1, $3); }
| exp GE exp                { $$ = ast_mk_exp_op(0, kind_op_ge,     $1, $3); }
| MINUS exp %prec UMINUS    { $$ = ast_mk_exp_op(0, kind_op_minus,  ast_mk_exp_int(0, 0), $2); }

exp_call
: ID LPAREN RPAREN                  { $$ = ast_mk_exp_call(0, sym_get($1), NULL); }
| ID LPAREN arg_fields RPAREN  { $$ = ast_mk_exp_call(0, sym_get($1), $3); }

exp_create
: ID LBRACE RBRACE                  { $$ = ast_mk_exp_record(0, sym_get($1), NULL); }
| ID LBRACE record_fields RBRACE    { $$ = ast_mk_exp_record(0, sym_get($1), $3); }
| ID LBRACK exp RBRACK OF exp       { $$ = ast_mk_exp_array(0, sym_get($1), $3, $6); }

exp_assign
: lvalue ASSIGN exp { $$ = ast_mk_exp_assign(0, $1, $3); }

exp_if
: IF exp THEN exp ELSE exp  { $$ = ast_mk_exp_if(0, $2, $4, $6); }
| IF exp THEN exp           { $$ = ast_mk_exp_if(0, $2, $4, NULL); }
| exp AND exp               { $$ = ast_mk_exp_if(0, $1, $3, ast_mk_exp_int(0, 0)); }
| exp OR exp                { $$ = ast_mk_exp_if(0, $1, ast_mk_exp_int(0, 1), $3); }

exp_for
: FOR ID ASSIGN exp TO exp DO exp { $$ = ast_mk_exp_for(0, sym_get($2), $4, $6, $8); }

exp_while
: WHILE exp DO exp { $$ = ast_mk_exp_while(0, $2, $4); }

exp_break
: BREAK { $$ = ast_mk_exp_break(0); }

exp_let
: LET decs IN END               { $$ = ast_mk_exp_let(0, $2, NULL); }
| LET decs IN seq_fields END    { $$ = ast_mk_exp_let(0, $2, $4); }

/****************************************************************************
 * variables
 ****************************************************************************/

lvalue
: ID                        { $$ = ast_mk_var(0, sym_get($1)); }
| lvalue LBRACK exp RBRACK  { $$ = ast_mk_var_slice(0, $1, $3); }
| lvalue DOT ID             { $$ = ast_mk_var_member(0, $1, sym_get($3)); }

/****************************************************************************
 * types
 ****************************************************************************/

type
: ID                            { $$ = ast_mk_type_var(0, sym_get($1)); }
| ARRAY OF ID                   { $$ = ast_mk_type_array(0, sym_get($3)); }
| LBRACE record_fields RBRACE   { $$ = ast_mk_type_record(0, $2); }
| LBRACE RBRACE                 { $$ = ast_mk_type_record(0, NULL); }

/****************************************************************************
 * link list
 ****************************************************************************/

type_fields
: type_field                   { $$ = ast_mk_tfield_list($1, NULL); }
| type_field COMMA type_fields { $$ = ast_mk_tfield_list($1, $3); }

type_field
: ID COLON ID   { $$ = ast_mk_tfield(0, sym_get($1), sym_get($3)); }

record_fields
: record_field                     { $$ = ast_mk_rfield_list($1, NULL); }
| record_field COMMA record_fields { $$ = ast_mk_rfield_list($1, $3); }

record_field
: ID EQ exp { $$ = ast_mk_rfield(sym_get($1), $3); }

seq_fields
: exp                      { $$ = ast_mk_exp_list($1, NULL); }
| exp SEMICOLON seq_fields { $$ = ast_mk_exp_list($1, $3); }

arg_fields
: exp                   { $$ = ast_mk_exp_list($1, NULL); }
| exp COMMA arg_fields  { $$ = ast_mk_exp_list($1, $3); }
